#!/bin/bash
# viral_detection 0.0.1
# Generated by dx-app-wizard.
#original author: Allison Cheney
#please email the original author with any questions you might have at archeney at ucsc.edu
set -e -x -o pipefail

samtools --version
samtools --version-only

echo "Value of input_hg19_mapped_bam: '$input_hg19_mapped_bam'"
echo "Value of prefix: '$input_hg19_mapped_bam_prefix'"
echo "Value of path: '$input_hg19_mapped_bam_path'"
echo "Value of name: '$input_hg19_mapped_bam_name'"

dx download "$input_hg19_mapped_bam" -o input_hg19_mapped_bam
dx download "$input_viral_reference_fasta" -o input_viral_reference_fasta
dx download "$input_viral_gene_bed" -o input_viral_gene_bed
#dx download "$input_probe_reference_fasta" -o input_probe_reference_fasta


bam_fname=$(dx describe --name ${input_hg19_mapped_bam_name})
if [[ $bam_fname == *".deduplicated.realign.bam" ]]
then
          sample_name="${bam_fname%.deduplicated.realign.bam}"
else
          sample_name="${bam_fname%.bam}"
fi
echo "Value of sample_name: '$sample_name'"

#get some basic stats for reporting later
samtools flagstat input_hg19_mapped_bam > flagstat_orig.txt
nhum=$( grep 'mapped (' flagstat_orig.txt | awk '{print $1}')
echo $nhum
nall=$( grep 'in total (' flagstat_orig.txt | awk '{print $1}')
echo $nall
#
# extract unmapped reads
#
echo "extract unmapped reads"
samtools view -f 0x4 -b input_hg19_mapped_bam > human_unmapped.bam

echo "sorting bam"
samtools sort -n human_unmapped.bam -o human_unmapped_sorted.bam
#n option: sort by readname
#Note that if the sorted output file is to be indexed with samtools index, the default coordinate sort must be used.
#Thus the -n, -t and -M options are incompatible with samtools index.

nhunmap=$(samtools flagstat human_unmapped_sorted.bam | grep 'in total (' | awk '{print $1}')
echo $nhunmap

echo "converting unmapped bam to fastqs"
samtools fastq human_unmapped_sorted.bam \
  -1 reads_unmapped.fastq.gz \
  -2 reads2_unmapped.fastq.gz \
  -s reads_singleton_unmapped.fastq.gz

#
# bwa mem mapping
#
bwa_opts=""
if [ "$bwa_advanced_options" != "" ]; then
  bwa_opts="$bwa_advanced_options"
fi

echo "mapping paired reads to viral references..."

bwa index input_viral_reference_fasta
bwa mem $bwa_opts input_viral_reference_fasta reads_unmapped.fastq.gz reads2_unmapped.fastq.gz > mappedviral_unsorted.bam

samtools sort mappedviral_unsorted.bam -o mappedviral_sorted.bam

#
#filtering out reads with a low mapq score
#
mapped_viral_bam_name="${sample_name}_mappedviral.bam"
echo "Value of mapq filter: '$mapq_filter'"
samtools view -q $mapq_filter -h mappedviral_sorted.bam > ${mapped_viral_bam_name}
samtools view -c ${mapped_viral_bam_name}
samtools sort ${mapped_viral_bam_name} -o ${mapped_viral_bam_name}
#echo "generating index for viral alignment..."
samtools index ${mapped_viral_bam_name}

#
# basic output info
#

#reads that mapped to any viral reference sequence
nvirmapn=$(samtools flagstat ${mapped_viral_bam_name} | grep 'mapped (' | awk '{print $1}')
#n_unmap=$($nhunmap - $nvirmapn)
echo -e "Read summary\nsample ID: "$sample_name"\ntotal reads: "$nall"\nreads that mapped to hg19: "$nhum"\nreads that did not map to hg19: "$nhunmap"\nviral-mapped reads: "$nvirmapn"\n\n" > basicoutput.tsv

if [[ nvirmapn < $count_cutoff ]]; then
  echo "No reads map to viral sequences in reference file or number of reads is below cutoff"
  #making dummy files
  echo -e "sample_name\tvirus_name\tpercent_reads_mapped\tmapped_reads_count\n"$sample_name"\tNone detected or below cutoff"  > ${sample_name}_viral_annot_results_NEGATIVE.tsv
  viral_geno_annot_res_tsv_name="${sample_name}_viral_annot_results_NEGATIVE.tsv"
  viral_geno_annot_res_tsv=$(dx upload "$viral_geno_annot_res_tsv_name" --brief)
  dx-jobutil-add-output viral_geno_annot_res_tsv "$viral_geno_annot_res_tsv" --class=file

  #upload a file with the basic output information and nothing more
  combined_annot_res_tsv=$(dx upload basicoutput.tsv -o "$sample_name._viral_annot_results" --brief)
  dx-jobutil-add-output combined_annot_res_tsv "$combined_annot_res_tsv" --class=file

  viral_gene_coverage_results_tsv_name="${sample_name}_viral_gene_coverage_results.tsv"
  echo -e "\n\nGene coverage\nvirus_name\tgene_name\tstart\tend\tbases_covered\tgene_length\tfraction_bases_covered\tread_count\nNone detected or below cutoff" > ${viral_gene_coverage_results_tsv_name}
  viral_gene_coverage_results_tsv=$(dx upload "$viral_gene_coverage_results_tsv_name" --brief)
  dx-jobutil-add-output viral_gene_coverage_results_tsv "$viral_gene_coverage_results_tsv" --class=file

  coverage_stats_tsv_name="${sample_name}_coverage_stats.tsv"
  echo -e "No reads map to viral sequences in reference file or number of reads is below cutoff"  > {$coverage_stats_tsv_name}
  coverage_stats_tsv=$(dx upload "$coverage_stats_tsv_name" --brief)
  dx-jobutil-add-output coverage_stats_tsv "$coverage_stats_tsv" --class=file

  echo -e "No reads map to viral sequences in reference file or number of reads is below cutoff"  > {$mapped_viral_bam_name}
  mapped_viral_bam=$(dx upload "$mapped_viral_bam_name" --brief)
  dx-jobutil-add-output mapped_viral_bam "$mapped_viral_bam" --class=file

  coverage_sorted_bed_name="${sample_name}_coverage_sorted.bed"
  echo -e "No reads map to viral sequences in reference file or number of reads is below cutoff"  > {$coverage_sorted_bed_name}
  coverage_sorted_bed=$(dx upload "$coverage_sorted_bed_name" --brief)
  dx-jobutil-add-output coverage_sorted_bed "$coverage_sorted_bed" --class=file
else
  #
  # basic mapping information per virus type
  #

  #note that this does not group virus subtypes together...
  #for example HPV16 and HPV30 are considered separately

  echo "generating viral genotype information"
  #getting counts for each viral genotype
  samtools idxstats ${mapped_viral_bam_name} | cut -f1,3 | sort -k2,2nr > viral_counts.tsv

  #filtering out viral genotypes with less than 10 reads as the default
  echo "Filtering out viral genotypes with fewer reads than: '$count_cutoff'"
  awk -v cutoff=$count_cutoff '$2>=cutoff{print}' viral_counts.tsv > temp.tsv
  awk -v tot=$nvirmapn '{printf("%s\t%.02f\t%i\n", $1, $2/tot, $2)}' temp.tsv > viralgenotyping.freq.tsv
  #column names: virusname, percent of read counts, mapped read count

  sort -k3,3nr -b -i viralgenotyping.freq.tsv | awk -v samplename=$sample_name '{print samplename"\t"$0}' > viralgenotyping_sort.freq.tsv
  viral_geno_annot_res_tsv_name="${sample_name}_viral_annot_results.tsv"
  { echo -e "sample_name\tvirus_name\tpercent_reads_mapped\tmapped_reads_count" ; cat viralgenotyping_sort.freq.tsv ; } > ${viral_geno_annot_res_tsv_name}
  #warning: altering the spacing of the above line breaks it for some reason
  #adds column names to the top of the file, which is apparently impossible to do in place
  #only viral_geno_annot_res_tsv from this section is included in the final output

  cut -f 1 viralgenotyping.freq.tsv| LC_ALL=C sort | uniq > viral_names_above_threshold.txt
  #makes file with names of viruses to include which we will use a lot later

  #
  # basic viral genotype coverage
  #
  echo "generating viral coverage bed file"
  bedtools genomecov -ibam ${mapped_viral_bam_name} | LC_ALL=C sort -t$'\t' -k1,1 > ${sample_name}_coverage.bed
  #column names: name of virus, depth, number of bases at that depth, viral reference length, fraction of bases at the depth
  coverage_sorted_bed_name="${sample_name}_coverage_sorted.bed"
  #join to exclude viruses with no reads
  join -t$'\t' -1 1 -2 1   ${sample_name}_coverage.bed viral_names_above_threshold.txt \
  | sort -t$'\t' -k2,2n > ${coverage_sorted_bed_name}

  #
  #  viral coverage depth statistics
  #
  #produces: simplepos.bed, temp_cov_depth_stats.tsv, coverage_stats_tsv_name

  #this time using genomecov to get the coverage at every *base* for further calculations
  bedtools genomecov -d -ibam ${mapped_viral_bam_name} > simplepos.bed

  # this part gets the lowest coverage depth at any base, the highest coverage depth, and the mean coverage
  for line in $(cat viral_names_above_threshold.txt)
  do
      awk -v line=$line '($1==line ){if ($1 in low) {
              if ($3 < low[$1])
                  low[$1] = $3
              if ($3 > hi[$1])
                  hi[$1] = $3
              sum[$1] += $3
              virct[$1]++            }
          else {
              virname[n++] = $1
              low[$1] = $3
              hi[$1]  = $3
              sum[$1] = $3
              virct[$1] = 1
          }
      }
      END {
          for (i=0; i<n; i++)
              printf "%s\t%d\t%d\t%d\t%.2f\n", virname[i], virct[virname[i]],low[virname[i]], hi[virname[i]], sum[virname[i]]/virct[virname[i]]}' simplepos.bed
  done > temp_cov_depth_stats.tsv



  #
  #  viral coverage counts
  #
  #produces: temp_cov_threshold_count.tsv
  #this part iterates over the file with names of viruses that were detected over the threshold AND
  #iterates over the bed file (sample_name_coverage.bed) line by line and gets:
  #the fraction of the reference genome with less than 25 reads,
  #the fraction with less than 50 reads, the fraction with less than 100 reads,
  #the fraction with more than 100 reads, and the fraction with 0 coverage
  #do not use coverage_sorted_bed_name instead or the whole thing will explode
  for line in $(cat viral_names_above_threshold.txt)
  do
      awk -v line=$line '($1==line && $2<= 25 && $2<0){cov25+=$5}
      ($1==line && $2<= 50 && $2>0){cov50+=$5}
      ($1==line && $2<100 && $2>0){cov100+=$5}
      ($1==line && $2>=100){covab100+=$5}
      ($1==line && $2==0){zcov+=$5}
      END{OFS="\t";  cov25+=0.00000; cov50+=0.00000; cov100+=0.000000; covab100+=0.00000; zcov+=0.00000;
      printf "%s\t%.06f\t%.06f\t%.06f\t%.06f\t%.06f\n", line,cov25,cov50,cov100, covab100, zcov}' ${sample_name}_coverage.bed
  done > temp_cov_threshold_count.tsv

  #
  # viral GENE coverage
  #
  bedtools coverage -a input_viral_gene_bed -b ${mapped_viral_bam_name} > viral_gene_coverage.tsv
  #use bedfile with gene annotations for each strain and mapped bam
  #column names: strain_name, startpos, endpos, 4genename, 5The number of features in B that overlapped (by at least one base pair) the A interval,
  #6The number of bases in A that had non-zero coverage from features in B, 7The length of the entry in A,
  #8The fraction of bases in A that had non-zero coverage from features in B

  awk '{if ($6>=1) printf("%s\t%s\t%s\t%i\t%i\t%i\t%i\t%.07f\n",$1"_"$4, $1,  $4, $2, $3, $6, $7,$8 )}' viral_gene_coverage.tsv \
  | LC_ALL=C sort -t$'\t' -k1,1  > viral_gene_coverage_sort.tsv
  #column names: virus_name, gene_name, start, end,   bases_covered, gene_length, fraction_bases_covered

  #simply gets the read count per gene, which isn't available as an option if you want the fraction as well
  bedtools coverage -a input_viral_gene_bed -b ${mapped_viral_bam_name} -counts \
  |  awk '{if ($5>=1) printf("%s\t%i\n",$1"_"$4, $5 )}' \
  | LC_ALL=C sort -t$'\t' -k1,1  > viral_gene_coverage_count.tsv
  #join to combine the fraction coverage with the coverage count

  join -t$'\t' -1 1 -2 1 viral_gene_coverage_sort.tsv viral_gene_coverage_count.tsv \
  | cut -f 2,3,4,5,6,7,8,9 | sort -k8,8nr \
  > viral_gene_coverage_results_tmp.tsv
  #column names: virus_name, gene_name, start, end,   bases_covered, gene_length, fraction_bases_covered, counts

  viral_gene_coverage_results_tsv_name="${sample_name}_viral_gene_coverage_results.tsv"

  { echo -e "\n\nGene coverage\nvirus_name\tgene_name\tstart\tend\tbases_covered\tgene_length\tfraction_bases_covered\tread_count" ; cat viral_gene_coverage_results_tmp.tsv ; } > ${viral_gene_coverage_results_tsv_name}

  #
  # Reformatting/combining files for output
  #
  sort -t$'\t' -k1,1 temp_cov_threshold_count.tsv > temp_cov_threshold_count_sort.tsv
  #must sort to join and you cannot sort in place
  #has to be sorted by name to join
  sort -t$'\t' -k1,1 viralgenotyping.freq.tsv > viralgenotyping_namesort.freq.tsv
  #combining the simple count information and the basic coverage depth stats
  join -t$'\t' -1 1 -2 1 viralgenotyping_namesort.freq.tsv temp_cov_depth_stats.tsv | sort -t$'\t' -k1,1 > testcomb.tsv

  #combining the coverage information together
  join -t$'\t' -1 1 -2 1 testcomb.tsv temp_cov_threshold_count_sort.tsv  | cut -f1,2,3,5,6,7,8,9,10,11,12 | awk -v samplename=$sample_name '{print samplename"\t"$0}' > testcomb2.tsv
  #cov25,cov50,cov100, covab100, zcov
  coverage_stats_tsv_name="${sample_name}_coverage_stats.tsv"
  { echo -e "Sequence mapping and coverage\nsample_name\tvirus_name\tfrac_of_all_viral_reads\tmapped_reads\tlowest_cov_depth\thighest_cov_depth\tmean_cov_depth\tfrac_below_25Xcov\tfrac_below_50Xcov\tfrac_below_100Xcov\tfrac_above_100Xcov\tfrac_0_cov" ; cat testcomb2.tsv ; } > ${coverage_stats_tsv_name}


  #combine the basic coverage and gene annotations together in one file for fun
  #the gene coverage file is also available separately
  combined_annot_res_tsv_name="${sample_name}_combined_annot_res.tsv"
  cat basicoutput.tsv ${coverage_stats_tsv_name} ${viral_gene_coverage_results_tsv_name} > ${combined_annot_res_tsv_name}

  combined_annot_res_tsv=$(dx upload "$combined_annot_res_tsv_name" --brief)
  dx-jobutil-add-output combined_annot_res_tsv "$combined_annot_res_tsv" --class=file

  viral_gene_coverage_results_tsv=$(dx upload "$viral_gene_coverage_results_tsv_name" --brief)
  dx-jobutil-add-output viral_gene_coverage_results_tsv "$viral_gene_coverage_results_tsv" --class=file

  viral_geno_annot_res_tsv=$(dx upload "$viral_geno_annot_res_tsv_name" --brief)
  dx-jobutil-add-output viral_geno_annot_res_tsv "$viral_geno_annot_res_tsv" --class=file

  coverage_sorted_bed=$(dx upload "$coverage_sorted_bed_name" --brief)
  dx-jobutil-add-output coverage_sorted_bed "$coverage_sorted_bed" --class=file

  coverage_stats_tsv=$(dx upload "$coverage_stats_tsv_name" --brief)
  dx-jobutil-add-output coverage_stats_tsv "$coverage_stats_tsv" --class=file

  mapped_viral_bam=$(dx upload "$mapped_viral_bam_name" --brief)
  dx-jobutil-add-output mapped_viral_bam "$mapped_viral_bam" --class=file
fi

echo "done"
